import {AbstractMesh, SceneLoader} from "@babylonjs/core";import {Scene} from "@babylonjs/core/scene";import {Vector3} from "@babylonjs/core/Maths/math.vector";import {FurMaterial} from "@babylonjs/materials/fur/furMaterial";export default function (scene: Scene): void {  const material: FurMaterial = new FurMaterial("grid", scene);  material.furColor = new BABYLON.Color3(0.8, 0.8, 0.8);  material.furOcclusion = 1;  material.furLength = 0;  SceneLoader.Append(    "./src/3d/",    "woodland_shoe.stl",    scene,    (scene: Scene): void => {      scene.meshes.forEach((mesh: AbstractMesh): void => {        const thisName: string = "woodland_shoe_fur";        if (mesh.name === "stlmesh") mesh.name = thisName;        if (mesh.name !== thisName) return;        mesh.position = new Vector3(0, 0, -3);        mesh.scaling = new Vector3(0.1, 0.1, 0.1);        mesh.material = material;      });    },    null,    (scene: Scene, message: string, exception: unknown): void => {      console.error(message, exception, scene);    },  );  const colors: number[][] = [    [0.8, 0.8, 0.8],    [0.6, 0.8, 0.8],    [0.4, 0.8, 0.8],    [0.2, 0.8, 0.8]  ];  for (const [col, i] of <[number[], number][]>colors.map((e: number[], i: number) => [e, i + 1])) {    (<HTMLElement>document.getElementById(`button${i}`)).addEventListener('mousedown', () => {      scene.meshes.forEach((mesh: AbstractMesh): void => {        if (!mesh.name.endsWith('fur')) return;        material.furColor = new BABYLON.Color3(col[0], col[1], col[2]);        mesh.material = material;      });    });  }  const inputSize: HTMLInputElement = (<HTMLInputElement>document.getElementById('sizeSelector'));  inputSize.addEventListener('change', (): void => {    scene.meshes.forEach((mesh: AbstractMesh): void => {      if (!mesh.name.endsWith('fur')) return;      material.furLength = Number(inputSize.value);      mesh.material = material;    });  });}